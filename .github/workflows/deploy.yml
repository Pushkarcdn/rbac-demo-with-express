name: RBAC Demo Backend Deployment

on:
  push:
    branches: [main]

env:
  PROJECT_NAME: rbac-demo-with-express
  SERVER_IP: ${{ secrets.SERVER_IP }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_KEY: ${{ secrets.SSH_KEY }}
  SERVER_PASS: ${{ secrets.SERVER_PASS }}
  APP_ENV: ${{ secrets.APP_ENV }}
  NODE_ENV: production
  EXTERNAL_PORT: ${{ secrets.APP_PORT }}
  INTERNAL_PORT: ${{ secrets.APP_PORT }}
  WORKDIR: /app

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ env.SSH_KEY }}
          known_hosts: "just-a-placeholder-so-we-dont-get-errors"
          config: |
            Host target
              HostName ${{ env.SERVER_IP }}
              User ${{ env.SSH_USER }}
              StrictHostKeyChecking no

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          platforms: linux/arm64

      - name: Build Node Docker image
        run: |
          docker buildx build \
            --platform linux/arm64 \
            --file Dockerfile \
            --load \
            -t ${{ env.PROJECT_NAME }}:latest \
            --build-arg WORKDIR="${{ env.WORKDIR }}" \
            --build-arg NODE_ENV="${{ env.NODE_ENV }}" \
            --build-arg INTERNAL_PORT="${{ env.INTERNAL_PORT }}" \
            .

      - name: Save Docker image
        run: |
          docker save -o /tmp/${{ env.PROJECT_NAME }}-temp-app.tar ${{ env.PROJECT_NAME }}:latest

      - name: Deploy to server
        run: |
          scp /tmp/${{ env.PROJECT_NAME }}-temp-app.tar target:/tmp/
          scp docker-compose.yml target:/tmp/

          ssh target "bash -s" << 'EOF'
            export WORKDIR=${{ env.WORKDIR }}

            # Create and configure application directory
            mkdir -p ./projects/${{ env.PROJECT_NAME }}
            chown $USER:$USER ./projects/${{ env.PROJECT_NAME }}
            chmod 755 ./projects/${{ env.PROJECT_NAME }} 

            # Update environment file
            rm -rf ./projects/${{ env.PROJECT_NAME }}/.env.production || true
            echo "${{ env.APP_ENV }}" > ./projects/${{ env.PROJECT_NAME }}/.env.production
            chmod 644 ./projects/${{ env.PROJECT_NAME }}/.env.production  

            # remove old container if it exists
            docker rm -f ${{ env.PROJECT_NAME }} 2>/dev/null || true

            # remove old image if it exists
            docker rmi -f ${{ env.PROJECT_NAME }}:latest 2>/dev/null || true

            # Load new image
            docker load -i /tmp/${{ env.PROJECT_NAME }}-temp-app.tar   

            # Deploy with compose
            mv /tmp/docker-compose.yml ./projects/${{ env.PROJECT_NAME }}/
            cd ./projects/${{ env.PROJECT_NAME }}
            docker compose up -d --force-recreate
            echo "${{ secrets.SERVER_SUDO_PASSWORD }}" | sudo -S ufw allow ${{ env.EXTERNAL_PORT }}

            # Cleanup
            rm -f /tmp/${{ env.PROJECT_NAME }}-temp-app.tar
          EOF
